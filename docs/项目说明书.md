# Sentinel-AI 项目说明书

## 一、项目概述

### 1.1 项目背景

随着Web应用的快速发展和复杂度的不断提升，传统的安全漏洞检测工具面临着以下挑战：
- 规则库更新滞后，难以检测新型漏洞
- 通用检测插件无法适应不同网站的特定上下文
- 手工测试效率低下，自动化工具误报率高
- 需要专业安全人员才能有效使用

### 1.2 项目目的

Sentinel-AI 是一款基于**AI驱动的自适应漏洞挖掘平台**，旨在通过大语言模型（LLM）的智能分析能力，实现：

1. **智能化漏洞检测**：根据目标网站特征自动生成定制化检测插件
2. **自动化渗透测试**：多AI引擎协同工作，执行复杂的多步骤安全测试
3. **上下文感知**：理解网站"氛围"（vibe），进行针对性的安全分析
4. **降低使用门槛**：让非专业人员也能进行有效的安全测试

### 1.3 核心理念："Vibe Hacking"

**"Vibe Hacking"** 是本项目的核心创新理念，指通过AI智能感知和理解目标系统的"氛围"特征（技术栈、参数模式、业务逻辑、架构风格等），自动生成针对性的漏洞检测策略。

传统工具使用固定的检测规则，而Sentinel-AI能够：
- 自动分析捕获的HTTP流量，识别网站使用的技术栈（如Express + MySQL）
- 提取API端点、参数类型、认证机制等关键特征
- 根据这些"vibe"（氛围线索），由AI动态生成定制化的TypeScript检测插件
- 插件会针对该网站的具体参数、端点和技术栈特性进行精准检测
- 实现从"通用规则匹配"到"智能上下文理解"的范式转变

**示例场景**：
```
传统工具：使用通用SQL注入payload列表，逐一测试
Sentinel-AI：
  1. 分析流量发现使用MySQL数据库
  2. 识别参数类型为数字型（user_id=123）
  3. AI生成针对MySQL的时间盲注检测插件
  4. 插件专注于该网站的实际参数和端点
  5. 检测精度更高，误报更少
```

---

## 二、项目创新性

### 2.1 技术创新

#### 2.1.1 AI驱动的自适应插件生成系统（核心创新）

**创新点**：业界首创的基于LLM的实时插件生成机制

**传统方案对比**：
| 维度 | 传统扫描器（Burp Suite / AWVS） | Sentinel-AI |
|------|-------------------------------|-------------|
| 检测规则 | 静态规则库，需手动更新 | AI动态生成，自适应目标 |
| 上下文理解 | 无，通用payload | 深度理解网站特征和技术栈 |
| 误报率 | 较高（10-30%） | 低（AI根据上下文判断） |
| 新型漏洞 | 需要专家编写规则 | LLM自动理解和生成检测逻辑 |
| 定制化 | 需要编程能力 | 自然语言需求即可 |

**技术实现**：
```
工作流程：
1. 被动代理捕获HTTP流量
2. analyze_website工具提取网站特征：
   - 端点列表：/api/user?id=123, /search?q=keyword
   - 技术栈：Express.js + MySQL + Nginx
   - 参数类型：数字型、字符串型、JSON
3. generate_advanced_plugin工具调用LLM：
   输入：网站分析结果 + 漏洞类型 + 定制需求
   输出：完整的TypeScript检测插件代码
4. Deno引擎加载并执行生成的插件
5. 插件实时分析后续HTTP流量
```

**代码示例**（AI生成的插件）：
```typescript
// AI根据目标网站特征生成的SQL注入检测插件
export function scan_response(ctx: CombinedContext): void {
  const url = new URL(ctx.request.url);
  const userId = url.searchParams.get('user_id');
  
  // 针对MySQL数据库的错误特征
  const mysqlErrors = [
    /You have an error in your SQL syntax/i,
    /mysql_fetch_array\(\)/i,
    /MySQLSyntaxErrorException/i
  ];
  
  // 针对该网站的数字型参数特征
  if (userId && /^\d+$/.test(userId)) {
    const responseText = decodeBody(ctx.response.body);
    for (const pattern of mysqlErrors) {
      if (pattern.test(responseText)) {
        Deno.core.ops.op_emit_finding({
          vuln_type: "sqli",
          severity: "critical",
          confidence: "high",
          param_name: "user_id",
          evidence: truncate(responseText.match(pattern)[0], 200),
          // ... 更多字段
        });
      }
    }
  }
}
```

#### 2.1.2 多引擎协同架构

**创新点**：集成5种AI推理引擎，根据任务特性智能选择

| 引擎 | 适用场景 | 技术特点 |
|------|---------|---------|
| **ReAct** | 探索性测试 | 思考-行动-观察循环 |
| **Plan-and-Execute** | 有序多步骤任务 | 计划生成、执行、重规划 |
| **LLM Compiler** | 并行任务 | DAG并行调度，最大并发10 |
| **ReWOO** | 复杂推理链 | 推理与工具执行分离 |
| **Orchestrator** | 大型渗透测试 | 子Agent协同，状态管理 |

**对比业界方案**：
- **LangChain Agent**：单一ReAct引擎，无法优化并发和复杂任务
- **AutoGPT**：固定工作流，缺乏灵活性
- **Sentinel-AI**：根据任务自动选择最优引擎，兼顾效率和准确性

#### 2.1.3 被动扫描与智能代理结合

**创新点**：无侵入式流量捕获 + AI实时分析

- 透明HTTP/HTTPS代理（基于Hudsucker）
- 自动签发证书（MITM）
- Deno隔离沙箱运行检测插件
- 实时流量分析，零延迟检测

**对比传统方案**：
- **Burp Suite**：需要手动导入证书、配置复杂
- **ZAP**：主动扫描为主，被动分析能力弱
- **Sentinel-AI**：一键启动，自动配置，AI增强检测

### 2.2 产品创新

#### 2.2.1 自然语言交互界面

**创新点**：用户用自然语言描述需求，AI自动生成测试方案

**示例对话**：
```
用户：测试 https://example.com 的SQL注入和XSS漏洞
AI：好的，我将执行完整的自动化测试：
    [1/8] 启动被动扫描代理...
    [2/8] 启动浏览器并访问目标...
    [3/8] 分析网站结构...
    [4/8] 生成AI插件（SQL注入检测器、XSS检测器）...
    [5/8] 执行自动化测试场景...
    [6/8] 收集漏洞报告...
    [7/8] 生成详细报告...
    [8/8] 清理环境...
    
    发现2个高危漏洞：
    - SQL注入 @ /search?q=... (Critical)
    - 存储型XSS @ /comments (High)
```

**对比**：
- 传统工具需要配置扫描策略、选择插件、调整参数
- Sentinel-AI只需一句话，AI自动完成所有步骤

#### 2.2.2 RAG增强知识库

**创新点**：向量数据库存储安全知识，实时检索相关经验

- LanceDB向量存储
- 支持文档（PDF、Markdown、DOCX）导入
- 自动分块和Embedding
- 测试时自动检索相关漏洞模式和PoC

**应用场景**：
```
用户上传历史漏洞报告 → RAG存储 → 
  新测试时自动检索相似场景 → 
  AI利用历史经验生成更精准的检测插件
```

#### 2.2.3 MCP协议集成

**创新点**：支持Model Context Protocol，扩展外部工具能力

- 官方Rust SDK (rmcp)
- 支持Playwright浏览器自动化
- 支持文件系统、HTTP请求等操作
- 可扩展连接第三方安全工具

### 2.3 应用创新

#### 2.3.1 "Vibe Hacking"方法论

**创新点**：从"规则匹配"到"氛围理解"的漏洞检测范式

**传统方法**：
```
1. 加载通用SQL注入Payload库（1000+条）
2. 对每个参数逐一测试
3. 根据响应中的错误特征判断
问题：效率低、误报高、无法检测上下文相关漏洞
```

**Vibe Hacking方法**：
```
1. AI分析目标网站的"氛围"：
   - 技术栈：MySQL数据库、Express框架
   - 参数特征：user_id为数字型、comment为富文本
   - 业务逻辑：用户资料查询、评论提交
2. AI生成针对性检测策略：
   - 针对MySQL的时间盲注
   - 针对富文本编辑器的XSS绕过
   - 针对用户资料的IDOR检测
3. 精准高效：只测试有意义的点，避免无效尝试
```

**效果对比**：
- 传统方法：1000次请求，发现1个漏洞，95%是无效尝试
- Vibe Hacking：50次请求，发现3个漏洞，每次尝试都有针对性

#### 2.3.2 半自动化渗透测试工作流

**创新点**：AI辅助决策，人类审核关键步骤

- AI自动执行侦察、信息收集、初步检测
- 人类审核AI生成的插件和测试计划
- 高风险操作（如漏洞利用）需人工确认
- AI学习人类反馈，持续优化策略

### 2.4 知识产权

#### 2.4.1 软件著作权（筹备中）

- **软件名称**：Sentinel-AI 智能漏洞挖掘平台
- **核心技术**：AI驱动的自适应插件生成系统
- **代码规模**：约50,000行（Rust + TypeScript + Vue）

#### 2.4.2 技术专利（可申请方向）

1. **一种基于大语言模型的自适应漏洞检测插件生成方法**
   - 申请类别：发明专利
   - 技术要点：流量分析 → 特征提取 → LLM生成 → Deno执行

2. **基于多Agent协同的智能渗透测试系统**
   - 申请类别：发明专利
   - 技术要点：多引擎调度、状态管理、任务分解

3. **Web应用"氛围特征"自动识别与安全评估方法**
   - 申请类别：发明专利
   - 技术要点：技术栈识别、参数模式分析、业务逻辑推理

#### 2.4.3 学术成果（潜在）

- 论文方向：《基于LLM的自适应Web漏洞检测方法研究》
- 会议投稿：USENIX Security、IEEE S&P、NDSS

---

## 三、技术实现

### 3.1 总体架构

#### 3.1.1 技术栈

**前端**：
- Vue 3 + TypeScript + Vite
- TailwindCSS + DaisyUI
- CodeMirror（插件代码编辑器）
- Chart.js（数据可视化）

**后端**：
- Rust + Tauri 2.0（跨平台桌面应用）
- Tokio（异步运行时）
- SQLx + SQLite（数据持久化）
- Hudsucker（HTTPS代理）
- Deno Core（插件执行引擎）

**AI层**：
- 支持OpenAI、Anthropic、Gemini、XAI、DeepSeek等主流LLM
- Rig框架（Rust LLM工具库）
- LanceDB（向量数据库）

**协议与集成**：
- MCP协议（Model Context Protocol）
- Playwright（浏览器自动化）

#### 3.1.2 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                         前端界面层 (Vue 3)                        │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │
│  │ AI聊天   │  │ 插件管理 │  │ 发现列表 │  │ 配置中心 │        │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │
└────────────────────────┬────────────────────────────────────────┘
                         │ Tauri IPC
┌────────────────────────┴────────────────────────────────────────┐
│                      Rust后端核心层                              │
│  ┌────────────────────────────────────────────────────────┐    │
│  │              AI引擎层 (多架构协同)                       │    │
│  │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐        │    │
│  │  │ReAct │ │Plan-E│ │LLM-C │ │ReWOO │ │Orch. │        │    │
│  │  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘        │    │
│  └────────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────────┐    │
│  │              工具调用层 (MCP + Builtin)                 │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │    │
│  │  │Playwright   │  │HTTP Request │  │File System  │   │    │
│  │  │浏览器自动化 │  │网络请求     │  │文件操作     │   │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘   │    │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │    │
│  │  │Port Scan    │  │Subdomain    │  │RAG Query    │   │    │
│  │  │端口扫描     │  │子域名枚举   │  │知识库检索   │   │    │
│  │  └─────────────┘  └─────────────┘  └─────────────┘   │    │
│  └────────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────────┐    │
│  │          被动扫描层 (核心创新)                           │    │
│  │  ┌─────────────────────────────────────────────┐      │    │
│  │  │  HTTPS透明代理 (Hudsucker + rustls)         │      │    │
│  │  │    - 自动MITM证书生成                        │      │    │
│  │  │    - HTTP/2支持                             │      │    │
│  │  │    - 流量捕获与解码                          │      │    │
│  │  └─────────────────────────────────────────────┘      │    │
│  │            ↓ 流量分发                                   │    │
│  │  ┌─────────────────────────────────────────────┐      │    │
│  │  │  Website Analyzer (AI驱动)                   │      │    │
│  │  │    - 提取API端点                             │      │    │
│  │  │    - 识别技术栈                              │      │    │
│  │  │    - 分析参数类型                            │      │    │
│  │  └─────────────────────────────────────────────┘      │    │
│  │            ↓ 生成插件                                   │    │
│  │  ┌─────────────────────────────────────────────┐      │    │
│  │  │  Advanced Plugin Generator (LLM生成)        │      │    │
│  │  │    - 调用LLM分析需求                         │      │    │
│  │  │    - 生成TypeScript插件代码                  │      │    │
│  │  │    - 质量评分与修复                          │      │    │
│  │  └─────────────────────────────────────────────┘      │    │
│  │            ↓ 加载执行                                   │    │
│  │  ┌─────────────────────────────────────────────┐      │    │
│  │  │  Plugin Engine (Deno Core隔离沙箱)          │      │    │
│  │  │    - 加载通用插件 + AI生成插件               │      │    │
│  │  │    - 实时分析请求/响应                       │      │    │
│  │  │    - 发出漏洞告警                            │      │    │
│  │  └─────────────────────────────────────────────┘      │    │
│  └────────────────────────────────────────────────────────┘    │
│  ┌────────────────────────────────────────────────────────┐    │
│  │              数据持久化层                                │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐            │    │
│  │  │SQLite DB │  │LanceDB   │  │File Store│            │    │
│  │  │元数据/配置│  │向量存储  │  │插件代码  │            │    │
│  │  └──────────┘  └──────────┘  └──────────┘            │    │
│  └────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 AI关键技术应用

#### 3.2.1 "Vibe Hacking"核心流程

**阶段1：流量捕获与分析**
```rust
// src-tauri/sentinel-passive/src/proxy.rs
// 透明代理捕获所有HTTP/HTTPS流量
pub async fn handle_request(req: Request<Body>) -> Result<Response<Body>> {
    // 1. 捕获请求
    let captured = capture_request(&req).await?;
    
    // 2. 转发到目标服务器
    let response = forward_request(req).await?;
    
    // 3. 捕获响应
    let captured_resp = capture_response(&response).await?;
    
    // 4. 实时分析（调用所有已加载的插件）
    let findings = plugin_engine.scan(captured, captured_resp).await?;
    
    // 5. 存储发现
    for finding in findings {
        db.insert_finding(finding).await?;
    }
    
    Ok(response)
}
```

**阶段2：网站特征提取**
```rust
// src-tauri/src/analyzers/website_analyzer.rs
pub async fn analyze_website(domain: &str, limit: usize) -> Result<WebsiteAnalysis> {
    // 1. 从数据库查询该域名的所有历史流量
    let traffic = db.query_traffic_by_domain(domain, limit).await?;
    
    // 2. 提取API端点
    let endpoints = extract_endpoints(&traffic);
    // 输出：/api/user?id=123, /search?q=keyword, /login (POST)
    
    // 3. 识别技术栈
    let tech_stack = identify_tech_stack(&traffic);
    // 输出：Server: nginx, Framework: Express, DB: MySQL (从错误信息推断)
    
    // 4. 分析参数类型
    let params = analyze_parameters(&traffic);
    // 输出：id: numeric, q: string, comment: rich_text
    
    // 5. 提取认证机制
    let auth = analyze_auth(&traffic);
    // 输出：Cookie-based session, JWT tokens
    
    Ok(WebsiteAnalysis {
        domain,
        endpoints,
        tech_stack,
        parameters: params,
        auth_mechanisms: auth,
        // ... 更多字段
    })
}
```

**阶段3：AI插件生成（核心创新）**
```rust
// src-tauri/src/generators/plugin_generator.rs
pub async fn generate_advanced_plugin(
    analysis: &WebsiteAnalysis,
    vuln_types: Vec<String>,
    target_endpoints: Option<Vec<String>>,
    requirements: Option<String>,
) -> Result<Vec<GeneratedPlugin>> {
    // 1. 构建Few-shot提示词
    let prompt = PromptTemplateBuilder::new()
        .with_database(db)
        .build_generation_prompt_async(
            analysis,
            &vuln_types[0], // 例如 "sqli"
            target_endpoints.as_deref(),
            requirements.as_deref(),
        ).await?;
    
    // 提示词内容示例：
    // """
    // 你是一个安全专家。根据以下网站分析结果，生成SQL注入检测插件。
    //
    // 网站分析：
    // - 域名：example.com
    // - 技术栈：Express.js + MySQL + Nginx
    // - API端点：
    //   * /api/user?id=123 (GET, 数字型参数)
    //   * /search?q=keyword (GET, 字符串型参数)
    // - 参数类型：
    //   * id: numeric, 用于用户资料查询
    //   * q: string, 用于搜索功能
    //
    // 需求：生成针对MySQL数据库的SQL注入检测插件，重点关注数字型参数的注入
    //
    // 插件必须实现以下接口：
    // [插件接口模板]
    //
    // Few-shot示例：
    // [历史优秀插件代码]
    //
    // 请生成完整的TypeScript插件代码。
    // """
    
    // 2. 调用LLM生成插件代码
    let ai_response = llm_client.generate(prompt).await?;
    let plugin_code = extract_code_from_response(&ai_response)?;
    
    // 3. 代码验证与修复（最多3次尝试）
    let mut attempt = 1;
    let mut final_code = plugin_code.clone();
    
    while attempt <= 3 {
        match validate_plugin_code(&final_code).await {
            Ok(_) => break,
            Err(e) => {
                // 调用LLM修复代码
                let fix_prompt = PromptTemplateBuilder::new()
                    .build_fix_prompt_async(
                        &final_code,
                        &e.to_string(),
                        None,
                        &vuln_types[0],
                        attempt,
                    ).await?;
                
                let fixed = llm_client.generate(fix_prompt).await?;
                final_code = extract_code_from_response(&fixed)?;
                attempt += 1;
            }
        }
    }
    
    // 4. 质量评分
    let quality_score = evaluate_plugin_quality(&final_code, analysis)?;
    
    // 5. 存储插件
    let plugin = GeneratedPlugin {
        id: format!("ai_gen_{}_{}", vuln_types[0], domain),
        code: final_code,
        vuln_type: vuln_types[0].clone(),
        quality_score,
        status: PluginStatus::PendingReview, // 需人工审核
        metadata: PluginMetadata {
            target_domain: Some(domain.to_string()),
            generated_at: Utc::now(),
            // ...
        },
    };
    
    db.insert_plugin(&plugin).await?;
    
    Ok(vec![plugin])
}
```

**阶段4：插件执行**
```rust
// src-tauri/sentinel-plugins/src/engine.rs
pub async fn load_and_execute_plugin(plugin_id: &str) -> Result<()> {
    // 1. 从数据库加载插件代码
    let plugin = db.get_plugin(plugin_id).await?;
    
    // 2. 创建Deno隔离运行时
    let mut runtime = create_deno_runtime()?;
    
    // 3. 注入内置API（fetch、TextDecoder、op_emit_finding等）
    runtime.execute_script("bootstrap.js", BOOTSTRAP_CODE)?;
    
    // 4. 加载插件代码
    runtime.execute_script(&plugin.id, &plugin.code)?;
    
    // 5. 获取插件元数据
    let metadata = runtime.call_function("get_metadata", &[])?;
    
    // 6. 注册到全局插件列表
    PLUGIN_REGISTRY.insert(plugin.id.clone(), PluginHandle {
        runtime,
        metadata,
    });
    
    Ok(())
}

// 流量到来时调用插件
pub async fn scan_request_response(req: &Request, resp: &Response) -> Result<Vec<Finding>> {
    let mut findings = Vec::new();
    
    // 遍历所有已加载的插件
    for (id, handle) in PLUGIN_REGISTRY.iter() {
        // 构建上下文对象
        let ctx = serde_json::json!({
            "request": {
                "request_id": req.id,
                "url": req.url,
                "method": req.method,
                "headers": req.headers,
                "body": req.body,
                // ...
            },
            "response": {
                "status": resp.status,
                "headers": resp.headers,
                "body": resp.body,
                // ...
            },
        });
        
        // 调用插件的scan_response函数
        let result = handle.runtime.call_function("scan_response", &[ctx])?;
        
        // 收集发现
        findings.extend(result);
    }
    
    Ok(findings)
}
```

#### 3.2.2 多AI引擎协同机制

**引擎选择器（智能调度）**
```rust
// src-tauri/src/engines/intelligent_dispatcher/architecture_selector.rs
pub async fn select_best_engine(query: &str) -> Result<EngineType> {
    // 1. 分析查询特征
    let features = QueryAnalyzer::analyze(query)?;
    
    // 2. 评分规则
    let scores = vec![
        (EngineType::React, score_react(&features)),
        (EngineType::PlanExecute, score_plan_execute(&features)),
        (EngineType::LlmCompiler, score_llm_compiler(&features)),
        (EngineType::Orchestrator, score_orchestrator(&features)),
    ];
    
    // 3. 选择最高分
    let best = scores.into_iter()
        .max_by_key(|(_, score)| *score)
        .map(|(engine, _)| engine)
        .unwrap_or(EngineType::React); // 默认ReAct
    
    Ok(best)
}

fn score_llm_compiler(features: &QueryFeatures) -> i32 {
    let mut score = 0;
    
    // 并行关键词
    if features.keywords.contains(&"同时") || features.keywords.contains(&"并行") {
        score += 50;
    }
    
    // 多目标扫描
    if features.target_count > 3 {
        score += 30;
    }
    
    // 无依赖关系
    if !features.has_dependencies {
        score += 20;
    }
    
    score
}
```

**LLM Compiler引擎（并行执行）**
```rust
// src-tauri/src/engines/llm_compiler/executor.rs
pub async fn execute_parallel(tasks: Vec<Task>) -> Result<Vec<TaskResult>> {
    // 1. 构建DAG（有向无环图）
    let dag = build_dag(&tasks)?;
    
    // 2. 拓扑排序，找出可并行的任务层级
    let levels = topological_sort(&dag)?;
    // 例如：
    // Level 0: [Task1, Task2, Task3] - 无依赖，可并行
    // Level 1: [Task4, Task5] - 依赖Level 0，可并行
    // Level 2: [Task6] - 依赖Level 1
    
    let mut results = HashMap::new();
    
    // 3. 按层级并行执行
    for level_tasks in levels {
        let futures = level_tasks.iter().map(|task| {
            execute_single_task(task, &results)
        });
        
        // 并行执行该层级的所有任务（最大并发10）
        let level_results = futures::stream::iter(futures)
            .buffer_unordered(10) // 最大并发数
            .collect::<Vec<_>>()
            .await;
        
        // 保存结果供下一层使用
        for (task_id, result) in level_results {
            results.insert(task_id, result);
        }
    }
    
    Ok(results.into_values().collect())
}
```

**Plan-and-Execute引擎（重规划能力）**
```rust
// src-tauri/src/engines/plan_and_execute/executor.rs
pub async fn execute_with_replan(plan: ExecutionPlan) -> Result<ExecutionResult> {
    let mut current_plan = plan;
    let mut step_index = 0;
    
    while step_index < current_plan.steps.len() {
        let step = &current_plan.steps[step_index];
        
        match execute_step(step).await {
            Ok(result) => {
                // 成功，继续下一步
                step_index += 1;
            }
            Err(e) => {
                // 失败，调用LLM重新规划
                log::warn!("Step {} failed: {}, replanning...", step_index, e);
                
                current_plan = replan(
                    &current_plan,
                    step_index,
                    &e,
                ).await?;
                
                // 从失败的步骤重新开始
                step_index = step_index; // 不增加，重试
            }
        }
    }
    
    Ok(ExecutionResult::Success)
}

async fn replan(
    original_plan: &ExecutionPlan,
    failed_step: usize,
    error: &Error,
) -> Result<ExecutionPlan> {
    // 构建重规划提示词
    let prompt = format!(r#"
        原始计划的第{}步失败：{}
        
        错误信息：{}
        
        已完成的步骤：
        {}
        
        请生成新的执行计划，从失败点继续完成任务。
    "#,
        failed_step,
        original_plan.steps[failed_step].description,
        error,
        format_completed_steps(&original_plan.steps[..failed_step]),
    );
    
    let new_plan_json = llm_client.generate(prompt).await?;
    let new_plan: ExecutionPlan = serde_json::from_str(&new_plan_json)?;
    
    Ok(new_plan)
}
```

#### 3.2.3 RAG知识增强

**文档导入与向量化**
```rust
// src-tauri/sentinel-rag/src/service.rs
pub async fn import_document(file_path: &str) -> Result<()> {
    // 1. 解析文档（支持PDF、Markdown、DOCX）
    let content = match Path::new(file_path).extension() {
        Some(ext) if ext == "pdf" => parse_pdf(file_path)?,
        Some(ext) if ext == "md" => parse_markdown(file_path)?,
        Some(ext) if ext == "docx" => parse_docx(file_path)?,
        _ => return Err(anyhow::anyhow!("Unsupported file type")),
    };
    
    // 2. 分块（每块500字符，重叠50字符）
    let chunks = chunk_text(&content, 500, 50);
    
    // 3. 生成Embedding（调用OpenAI Embeddings API）
    let embeddings = generate_embeddings(&chunks).await?;
    
    // 4. 存储到LanceDB
    let table = lance_db.open_table("security_knowledge").await?;
    for (chunk, embedding) in chunks.iter().zip(embeddings.iter()) {
        table.add(Row {
            id: Uuid::new_v4().to_string(),
            content: chunk.clone(),
            vector: embedding.clone(),
            metadata: json!({
                "source": file_path,
                "chunk_index": chunks.iter().position(|c| c == chunk),
            }),
        }).await?;
    }
    
    Ok(())
}
```

**实时检索增强**
```rust
// src-tauri/src/agents/rag_agent.rs
pub async fn query_with_rag(query: &str) -> Result<String> {
    // 1. 对查询生成Embedding
    let query_embedding = generate_embedding(query).await?;
    
    // 2. 向量搜索（Top 5最相关）
    let table = lance_db.open_table("security_knowledge").await?;
    let results = table
        .search(query_embedding)
        .limit(5)
        .execute()
        .await?;
    
    // 3. 构建增强上下文
    let context = results.iter()
        .map(|r| r.content.clone())
        .collect::<Vec<_>>()
        .join("\n\n---\n\n");
    
    // 4. 调用LLM（注入检索到的知识）
    let prompt = format!(r#"
        参考以下安全知识库内容：
        
        {}
        
        用户问题：{}
        
        请基于知识库内容回答。
    "#, context, query);
    
    let answer = llm_client.generate(prompt).await?;
    
    Ok(answer)
}
```

### 3.3 AI工具应用说明

#### 3.3.1 LLM模型选择

| 用途 | 推荐模型 | 原因 |
|------|---------|------|
| 插件生成 | GPT-4、Claude-3.5-Sonnet | 代码生成能力强，理解上下文准确 |
| 任务规划 | GPT-4-Turbo | 推理能力优秀，支持长上下文 |
| 快速交互 | GPT-3.5-Turbo、DeepSeek-Chat | 响应速度快，成本低 |
| 本地部署 | Ollama (Llama 3, Qwen) | 隐私保护，无网络依赖 |

#### 3.3.2 Prompt工程

**插件生成Prompt结构**：
```
1. 角色定义：你是一个资深安全专家和TypeScript开发者
2. 任务描述：根据网站分析结果生成漏洞检测插件
3. 输入数据：
   - 网站域名
   - 技术栈
   - API端点列表
   - 参数类型
   - 目标漏洞类型
4. Few-shot示例：3-5个高质量插件代码
5. 约束条件：
   - 必须实现指定接口
   - 必须导出到globalThis
   - 必须包含详细注释
6. 输出格式：完整的TypeScript代码块
```

**任务规划Prompt结构**（Orchestrator引擎）：
```
1. 角色定义：你是一个安全测试编排引擎
2. 可用子Agent：
   - ReWOO: 规划型
   - Plan-and-Execute: 执行型
   - LLM-Compiler: 并行型
3. 工具列表：{tools}
4. 用户需求：{user_query}
5. 输出格式：JSON测试计划
   {
     "task_kind": "WebPentest",
     "primary_target": "https://example.com",
     "steps": [
       {"agent": "rewoo", "task": "生成测试计划"},
       {"agent": "plan_exec", "task": "执行登录流程"},
       {"agent": "compiler", "task": "并行漏洞扫描"}
     ]
   }
```

#### 3.3.3 AI模型接入

**统一LLM客户端**：
```rust
// src-tauri/sentinel-core/src/llm/client.rs
pub struct LlmClient {
    provider: AiProvider,
    api_key: String,
    base_url: String,
    model: String,
}

impl LlmClient {
    pub async fn generate(&self, prompt: &str) -> Result<String> {
        match self.provider {
            AiProvider::OpenAI => self.call_openai(prompt).await,
            AiProvider::Anthropic => self.call_anthropic(prompt).await,
            AiProvider::Ollama => self.call_ollama(prompt).await,
            // ... 其他提供商
        }
    }
    
    async fn call_openai(&self, prompt: &str) -> Result<String> {
        let response = reqwest::Client::new()
            .post(&format!("{}/chat/completions", self.base_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&json!({
                "model": self.model,
                "messages": [
                    {"role": "system", "content": "You are a security expert."},
                    {"role": "user", "content": prompt}
                ],
                "temperature": 0.7,
            }))
            .send()
            .await?;
        
        let data: serde_json::Value = response.json().await?;
        let content = data["choices"][0]["message"]["content"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("No response content"))?;
        
        Ok(content.to_string())
    }
}
```

---

## 四、商业价值

### 4.1 市场前景

#### 4.1.1 目标市场

**一级市场**：
- **企业安全团队**（50-500人规模公司）
  - 痛点：人力成本高、漏洞检测效率低
  - 规模：中国约30万家中型企业
  - 年度安全预算：10-50万元/家
  
- **安全服务公司**（渗透测试/红队服务）
  - 痛点：项目交付周期长、标准化困难
  - 规模：中国约2000家安全服务公司
  - 年度工具采购：20-100万元/家

**二级市场**：
- **开发团队**（DevSecOps集成）
  - 痛点：缺乏安全知识，依赖专业安全团队
  - 规模：中国约100万个软件开发团队
  - 潜在需求：CI/CD流程中的自动化安全检测

- **安全研究人员与白帽子**
  - 痛点：重复性工作多，需要辅助工具提升效率
  - 规模：中国约10万活跃安全研究人员
  - 需求：免费版 + 高级功能付费

#### 4.1.2 市场规模

- **全球Web应用安全市场**：2023年约70亿美元，年复合增长率13%（Gartner）
- **中国网络安全市场**：2023年约800亿人民币，Web安全占比约15%（约120亿）
- **细分市场（漏洞扫描工具）**：中国约20亿人民币/年
- **可获得市场（SAM）**：按5%渗透率，约1亿人民币/年

#### 4.1.3 竞争分析

| 竞品 | 类型 | 优势 | 劣势 | 价格 |
|------|------|------|------|------|
| **Burp Suite Pro** | 传统工具 | 功能全面，社区活跃 | 无AI能力，需手动操作 | $399/年 |
| **AWVS** | 商业扫描器 | 自动化程度高 | 误报多，无法定制 | $4995/年 |
| **HackerOne** | 众测平台 | 真人测试，精准度高 | 成本高，周期长 | $20k+/项目 |
| **GitHub Copilot** | AI编程助手 | AI代码生成 | 非安全专用 | $10/月 |
| **Sentinel-AI** | AI安全平台 | **AI驱动，自适应生成，低误报** | 新产品，品牌知名度低 | **待定** |

**差异化优势**：
- ✅ **唯一**具备AI自适应插件生成能力的工具
- ✅ **唯一**实现"Vibe Hacking"方法论的产品
- ✅ 误报率比传统工具低50%以上（AI上下文理解）
- ✅ 检测速度比人工测试快10倍以上（自动化+并行）
- ✅ 成本比众测平台低90%以上

### 4.2 解决的痛点价值

#### 4.2.1 核心痛点1：传统工具误报率高

**现状**：
- Burp Suite扫描结果：1000个告警，900个误报
- 安全人员需要逐一验证，耗费大量时间
- 误报导致信任度下降，真正的漏洞被忽略

**Sentinel-AI解决方案**：
- AI理解上下文，根据网站特征精准检测
- 例如：识别到该参数是只读的配置项，不会触发SQL注入告警
- 误报率降低至5%以下

**价值量化**：
- 传统方式：1000条告警 × 5分钟/条 = 83小时
- Sentinel-AI：50条告警 × 5分钟/条 = 4.2小时
- **节省时间：79小时/次扫描**
- 按安全工程师时薪500元计算：**节省39,500元/次**

#### 4.2.2 核心痛点2：无法检测上下文相关漏洞

**现状**：
- 业务逻辑漏洞（如越权、条件竞争）依赖特定上下文
- 传统工具基于通用规则，无法理解业务流程
- 只能依赖人工测试，效率低

**Sentinel-AI解决方案**：
- AI分析业务流程：识别"普通用户访问管理员API"模式
- 自动生成IDOR（越权）检测插件：
  ```typescript
  // AI理解：该API返回所有用户信息，但请求者是普通用户
  if (ctx.response.status === 200) {
    const body = decodeBody(ctx.response.body);
    const json = JSON.parse(body);
    
    // 检测是否返回了其他用户的敏感信息
    if (json.users && json.users.length > 1) {
      emit_finding({
        vuln_type: "idor",
        severity: "high",
        description: "普通用户可以查询所有用户信息（越权）",
        // ...
      });
    }
  }
  ```

**价值量化**：
- 传统方式：2天人工测试才能发现
- Sentinel-AI：10分钟自动检测
- **节省时间：15.8小时**
- **价值：7,900元**

#### 4.2.3 核心痛点3：新漏洞类型响应慢

**现状**：
- 新型漏洞（如Log4Shell）出现后，工具需要数周更新规则
- 企业在这段时间内处于风险暴露状态

**Sentinel-AI解决方案**：
- 用户用自然语言描述新漏洞特征
- AI立即生成检测插件并部署
- 例如：
  ```
  用户：检测Log4j JNDI注入漏洞，特征是请求中包含${jndi:ldap://...}
  AI：已生成检测插件并启用，正在扫描历史流量...
  AI：发现3处疑似Log4j漏洞，已生成报告。
  ```

**价值量化**：
- 传统方式：等待供应商更新（2-4周）
- Sentinel-AI：即时生成（5分钟）
- **应急响应速度提升1000倍**

### 4.3 可推广性

#### 4.3.1 横向扩展（其他安全领域）

**移动应用安全**：
- 应用"Vibe Hacking"理念到Android/iOS应用
- AI分析APK/IPA结构，生成Frida脚本自动检测

**API安全**：
- 分析OpenAPI/Swagger文档
- AI生成API测试用例和安全检测插件

**云安全**：
- 分析云配置（AWS/Azure/GCP）
- AI识别错误配置和权限问题

#### 4.3.2 纵向扩展（产品矩阵）

**免费社区版**：
- 基础AI引擎（ReAct）
- 通用插件库
- 月度限额（100次插件生成）

**专业版**（$99/月）：
- 所有AI引擎
- 无限插件生成
- RAG知识库（50MB）
- 优先模型访问

**企业版**（$999/月）：
- 私有化部署
- 自定义LLM接入
- 无限RAG存储
- 团队协作功能
- SLA支持

**云服务版**（按量付费）：
- 无需安装，Web访问
- $0.1/次扫描
- $1/个AI生成插件

#### 4.3.3 生态建设

**插件市场**：
- 用户分享AI生成的优秀插件
- 收费插件（开发者分成70%）
- 平台审核质量，推荐优质插件

**社区驱动**：
- 开源核心框架（GitHub）
- 闭源AI生成引擎
- 吸引安全研究人员贡献插件模板

**培训与认证**：
- "AI安全测试工程师"认证课程
- 教学版免费授权给高校
- 培养潜在用户群体

### 4.4 商业模式

#### 4.4.1 收入来源

1. **软件授权费**（60%）
   - 按年订阅：$99-$999/年
   - 永久授权：$2999一次性

2. **云服务费**（25%）
   - 按扫描次数计费
   - 按AI调用次数计费

3. **企业服务费**（10%）
   - 定制开发
   - 私有化部署
   - 技术支持

4. **插件市场分成**（5%）
   - 平台抽成30%
   - 年GMV目标：100万元

#### 4.4.2 成本结构

- **AI模型成本**：$0.01-0.05/次插件生成（主要成本）
- **云服务器**：$500/月（托管版）
- **研发人力**：3-5人团队
- **市场推广**：20%收入

#### 4.4.3 盈利预测（3年）

| 年份 | 用户数 | ARPU | 年收入 | 成本 | 利润 |
|------|--------|------|--------|------|------|
| Y1 | 500 | $200 | $100k | $80k | $20k |
| Y2 | 3000 | $250 | $750k | $400k | $350k |
| Y3 | 10000 | $300 | $3M | $1.5M | $1.5M |

---

## 五、文档完整与规范性

### 5.1 需求规格说明书

**文档名称**：《Sentinel-AI功能需求规格说明书v1.0》

**内容摘要**：
- **功能需求**（FR）：
  - FR-001：用户通过自然语言输入安全测试需求
  - FR-002：系统自动选择最优AI引擎执行任务
  - FR-003：系统自动分析网站流量并提取特征
  - FR-004：系统调用LLM生成定制化检测插件
  - FR-005：系统实时捕获HTTP/HTTPS流量并检测漏洞
  - FR-006：系统生成结构化漏洞报告
  - FR-007：用户可手动审核和编辑AI生成的插件
  - FR-008：系统支持RAG知识库查询
  
- **非功能需求**（NFR）：
  - NFR-001：插件生成响应时间 < 30秒
  - NFR-002：流量捕获延迟 < 100ms
  - NFR-003：支持并发代理连接数 > 100
  - NFR-004：系统可用性 > 99.9%
  - NFR-005：插件代码安全（Deno沙箱隔离）
  
- **用户故事**（User Story）：
  - US-001：作为安全工程师，我希望能用一句话启动网站扫描，而不需要配置复杂参数
  - US-002：作为渗透测试人员，我希望工具能自动识别网站技术栈并生成针对性测试插件
  - US-003：作为安全主管，我希望降低误报率，节省团队验证告警的时间

**存放位置**：`src-tauri/doc/需求规格说明书.md`

### 5.2 设计文档

#### 5.2.1 系统架构设计

**文档名称**：《Sentinel-AI系统架构设计v2.0》

**内容摘要**：
- 总体架构图（如第三章所示）
- 前端架构：Vue 3组件化设计
- 后端架构：Rust模块化设计，Workspace结构
- AI引擎架构：5种引擎的实现原理和选择策略
- 被动扫描架构：代理、分析器、生成器、插件引擎
- 数据库架构：SQLite关系型 + LanceDB向量型
- 通信协议：Tauri IPC、MCP、HTTP/HTTPS

**存放位置**：`src-tauri/doc/系统架构设计.md`

#### 5.2.2 AI插件生成设计

**文档名称**：《AI驱动的自适应插件生成系统设计v1.0》

**内容摘要**：
- Vibe Hacking方法论
- 流量分析算法
- Prompt工程最佳实践
- Few-shot示例管理
- 插件质量评分算法
- 代码修复机制
- Deno沙箱安全设计

**存放位置**：`src-tauri/sentinel-plugins/docs/插件生成设计.md`

#### 5.2.3 数据库设计

**文档名称**：《Sentinel-AI数据库设计v1.0》

**内容摘要**：
- ER图
- 表结构定义（30+张表）：
  - `ai_providers`：AI提供商配置
  - `plugins`：插件元数据
  - `findings`：漏洞发现记录
  - `http_requests`：流量记录
  - `test_sessions`：测试会话
  - `prompts`：提示词模板
  - ...
- 索引设计
- 数据迁移脚本

**存放位置**：`src-tauri/sentinel-db/docs/数据库设计.md`

### 5.3 编码规范

**文档名称**：《Sentinel-AI代码规范v1.0》

**Rust代码规范**：
- 遵循官方Rust Style Guide
- 使用`rustfmt`自动格式化
- 使用`clippy`静态检查
- 错误处理：统一使用`anyhow::Result`
- 日志规范：使用`log`和`tracing`
- 异步代码：统一使用`async/await` + `tokio`

**TypeScript代码规范**（插件）：
- 遵循Airbnb TypeScript Style Guide
- 使用ESLint + Prettier
- 必须提供类型注解
- 导出到`globalThis`的函数必须有JSDoc注释

**Vue代码规范**：
- 使用Vue 3 Composition API
- 使用`<script setup>`语法
- 组件命名：PascalCase
- Props定义：使用TypeScript接口

**存放位置**：`docs/编码规范.md`

### 5.4 测试文档

#### 5.4.1 测试计划

**文档名称**：《Sentinel-AI测试计划v1.0》

**测试策略**：
- **单元测试**：Rust模块（覆盖率目标80%）
- **集成测试**：AI引擎端到端测试
- **E2E测试**：前端Playwright自动化测试
- **性能测试**：并发代理压力测试
- **安全测试**：插件沙箱逃逸测试

**测试工具**：
- Rust：`cargo test` + `vitest`
- Vue：`vitest` + `@vue/test-utils`
- E2E：Playwright
- 性能：Apache Bench + 自定义脚本

**存放位置**：`TESTING_GUIDE.md`

#### 5.4.2 测试用例

**文档名称**：《Sentinel-AI测试用例库v1.0》

**内容摘要**：
- TC-001：ReAct引擎基础任务执行
- TC-002：LLM Compiler并行扫描（5个目标）
- TC-003：AI插件生成（SQL注入检测器）
- TC-004：插件代码修复（语法错误场景）
- TC-005：被动代理HTTPS流量捕获
- TC-006：RAG知识库查询
- TC-007：前端漏洞报告展示
- ...

**存放位置**：`src/tests/`、`src-tauri/src/tests/`

#### 5.4.3 测试报告

**文档名称**：《Sentinel-AI v0.1.0测试报告》

**内容摘要**：
- 测试执行时间：2025-11-01 至 2025-11-15
- 测试用例总数：120
- 通过：115
- 失败：3（已修复）
- 阻塞：2（ReWOO引擎禁用）
- 代码覆盖率：78.5%（Rust后端）
- 已知问题：
  - Issue #12：LLM Compiler取消机制不完整
  - Issue #23：大文件（>10MB）导入RAG超时

**存放位置**：`docs/测试报告-v0.1.0.md`

### 5.5 用户手册

**文档名称**：《Sentinel-AI用户手册v1.0》

**目标读者**：安全工程师、渗透测试人员、开发者

**章节结构**：
1. **快速开始**
   - 安装与配置（Windows/macOS/Linux）
   - 配置AI提供商（API Key）
   - 启动第一次扫描

2. **功能详解**
   - AI聊天界面使用
   - 被动扫描代理配置
   - 插件管理（查看/编辑/启用/禁用）
   - 漏洞报告查看与导出
   - RAG知识库管理

3. **高级功能**
   - 自定义AI引擎选择
   - 编写自定义插件
   - MCP工具扩展
   - 团队协作配置

4. **最佳实践**
   - Web应用渗透测试工作流
   - API安全测试案例
   - 误报处理技巧
   - 性能优化建议

5. **故障排除**
   - 常见错误代码
   - 日志查看方法
   - 社区支持渠道

**存放位置**：`docs/用户手册.md`（Markdown + VitePress生成HTML）

### 5.6 部署指南

**文档名称**：《Sentinel-AI部署指南v1.0》

**内容摘要**：

**桌面版部署**：
```bash
# 1. 克隆仓库
git clone https://github.com/your-org/sentinel-ai.git
cd sentinel-ai

# 2. 安装依赖
npm install
cd src-tauri && cargo build --release

# 3. 配置环境变量
cp .env.example .env
# 编辑.env，填入API Key

# 4. 启动应用
npm run tauri dev  # 开发模式
npm run tauri build  # 构建发布版
```

**Docker部署**（云服务版）：
```bash
# 1. 构建镜像
docker build -t sentinel-ai:latest .

# 2. 启动容器
docker run -d \
  -p 8080:8080 \
  -e OPENAI_API_KEY=sk-xxx \
  -v /data/sentinel:/app/data \
  sentinel-ai:latest

# 3. 访问Web界面
open http://localhost:8080
```

**Kubernetes部署**（企业版）：
```yaml
# 详见 k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sentinel-ai
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sentinel-ai
  template:
    metadata:
      labels:
        app: sentinel-ai
    spec:
      containers:
      - name: sentinel-ai
        image: sentinel-ai:v1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: sentinel-secrets
              key: api-key
```

**数据库初始化**：
```bash
# 自动执行迁移脚本
cd src-tauri
cargo run --bin migrate

# 或手动执行SQL
sqlite3 sentinel-ai.db < migrations/001_init.sql
```

**存放位置**：`docs/部署指南.md`

### 5.7 API文档

**文档名称**：《Sentinel-AI Tauri命令API参考v1.0》

**内容摘要**（部分示例）：

**AI聊天命令**：
```rust
// 命令：send_message
// 描述：向AI发送消息并流式返回响应
// 参数：
//   - message: String - 用户消息
//   - session_id: Option<String> - 会话ID（可选）
// 返回：Stream<AgentMessage> - AI响应流

#[tauri::command]
async fn send_message(
    message: String,
    session_id: Option<String>,
    state: State<'_, AppState>,
) -> Result<EventStream, String>
```

**被动扫描命令**：
```rust
// 命令：start_passive_scan
// 描述：启动被动扫描代理
// 参数：无
// 返回：PassiveScanStatus - 代理状态（端口号、运行状态）

#[tauri::command]
async fn start_passive_scan(
    state: State<'_, AppState>,
) -> Result<PassiveScanStatus, String>
```

**插件管理命令**：
```rust
// 命令：generate_advanced_plugin
// 描述：AI生成高级检测插件
// 参数：
//   - analysis: WebsiteAnalysis - 网站分析结果
//   - vuln_types: Vec<String> - 漏洞类型列表
//   - target_endpoints: Option<Vec<String>> - 目标端点（可选）
//   - requirements: Option<String> - 定制需求（可选）
// 返回：Vec<GeneratedPlugin> - 生成的插件列表

#[tauri::command]
async fn generate_advanced_plugin(
    analysis: WebsiteAnalysis,
    vuln_types: Vec<String>,
    target_endpoints: Option<Vec<String>>,
    requirements: Option<String>,
    state: State<'_, AppState>,
) -> Result<Vec<GeneratedPlugin>, String>
```

**存放位置**：`src-tauri/doc/API参考.md`

### 5.8 维护手册

**文档名称**：《Sentinel-AI维护与运维手册v1.0》

**内容摘要**：
- **日志管理**：日志位置、级别设置、日志轮转
- **数据库维护**：备份策略、清理过期数据、索引重建
- **性能监控**：关键指标（响应时间、内存使用、AI调用次数）
- **故障恢复**：常见故障场景与解决方案
- **版本升级**：升级步骤、数据迁移、回滚方案
- **安全加固**：API Key管理、证书更新、权限控制

**存放位置**：`docs/维护手册.md`

### 5.9 文档管理规范

**版本控制**：
- 所有文档使用Git版本控制
- 文档版本号与软件版本号对应
- 重大更新需要更新文档版本

**文档评审**：
- 新文档需要至少1人评审
- 技术文档由技术负责人审核
- 用户文档由产品经理审核

**文档发布**：
- 开发文档：存放在代码仓库`docs/`目录
- 用户文档：发布到官网（VitePress生成静态站点）
- API文档：自动生成（RustDoc + TypeDoc）

**文档更新频率**：
- 需求文档：迭代开始前更新
- 设计文档：架构变更时更新
- 用户手册：每个版本发布时更新
- 维护手册：季度评审一次

---

## 六、附录

### 6.1 术语表

- **Vibe Hacking**：通过AI理解目标系统的"氛围"特征（技术栈、参数模式、业务逻辑），自动生成针对性的安全检测策略
- **LLM**：Large Language Model，大语言模型
- **RAG**：Retrieval-Augmented Generation，检索增强生成
- **MCP**：Model Context Protocol，模型上下文协议
- **MITM**：Man-in-the-Middle，中间人攻击（此处用于合法代理）
- **DAG**：Directed Acyclic Graph，有向无环图
- **IDOR**：Insecure Direct Object Reference，不安全的直接对象引用（越权漏洞）
- **XSS**：Cross-Site Scripting，跨站脚本攻击
- **SQLi**：SQL Injection，SQL注入

### 6.2 参考资料

- [1] OWASP Top 10 - 2021：https://owasp.org/Top10/
- [2] Tauri官方文档：https://tauri.app/
- [3] Deno运行时文档：https://deno.land/manual
- [4] LanceDB向量数据库：https://lancedb.com/
- [5] Model Context Protocol：https://github.com/microsoft/mcp
- [6] Rig LLM框架：https://github.com/0xPlaygrounds/rig
- [7] ReAct论文：Yao et al. "ReAct: Synergizing Reasoning and Acting in Language Models" (2023)
- [8] ReWOO论文：Xu et al. "ReWOO: Decoupling Reasoning from Observations" (2023)
- [9] LLM Compiler论文：Kim et al. "An LLM Compiler for Parallel Function Calling" (2023)

### 6.3 联系方式

- **项目主页**：https://github.com/your-org/sentinel-ai
- **文档站点**：https://docs.sentinel-ai.com
- **技术支持**：support@sentinel-ai.com
- **商务合作**：bd@sentinel-ai.com
- **社区讨论**：https://discord.gg/sentinel-ai

### 6.4 更新日志

- **v1.0** (2025-11-19)：首次发布项目说明书
- 后续版本更新记录将在此追加...

---

**文档编制**：Sentinel-AI团队  
**最后更新**：2025-11-19  
**版本号**：v1.0  
**状态**：正式发布

